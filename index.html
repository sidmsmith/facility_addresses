<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Update Facility Addresses v2.2.0</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <!-- CodeMirror for JSON syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/json/json.min.js"></script>
  <style>
    :root {
      --bg-dark: #121212;
      --card-bg: #1e1e1e;
      --input-bg: #2d2d2d;
      --border: #333;
      --text: #e0e0e0;
      --red-bg: #4a1a1a;
      --red-text: #ff6b6b;
      --blue-select: #339af0;
      --success: #28a745;
      --primary: #0d6efd;
    }
    
    /* Dark theme (existing theme) */
    :root.theme-dark {
      --bg-dark: #121212;
      --card-bg: #1e1e1e;
      --input-bg: #2d2d2d;
      --border: #333;
      --text: #e0e0e0;
      --red-bg: #4a1a1a;
      --red-text: #ff6b6b;
      --blue-select: #339af0;
      --success: #28a745;
      --primary: #0d6efd;
    }
    
    /* Manhattan theme */
    :root.theme-manhattan {
      --bg-dark: rgb(45, 47, 59);
      --card-bg: #484e5e;
      --input-bg: #282c34;
      --border: #333;
      --text: #495057;
      --red-bg: #4a1a1a;
      --red-text: #ff6b6b;
      --blue-select: #339af0;
      --success: hsl(142.1 76.2% 36.3%);
      --primary: #3B82F6;
      --secondary: #6c757d;
      --shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    body { 
      background: var(--bg-dark); 
      color: var(--text); 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      min-height: 100vh;
      margin: 0;
    }

    .main-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      padding: 1.5rem;
      margin: 1rem;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    @media (min-width: 769px) {
      .main-card { max-width: 900px; margin: 2rem auto; }
    }

    .form-control, .form-select, textarea {
      background: var(--input-bg);
      border: 1px solid #444;
      color: #fff;
      border-radius: 8px;
    }
    .form-control:focus, .form-select:focus, textarea:focus {
      background: #333;
      border-color: var(--primary);
      box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);
      color: #fff;
    }

    .btn-primary { background: var(--primary); border: none; }
    .btn-success { background: var(--success); border: none; }
    .btn-secondary { background: #6c757d; border: none; }
    .btn-primary:hover { background: #0b5ed7; }
    .btn-success:hover { background: #218838; }
    .btn-secondary:hover { background: #5a6268; }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 1rem 0 0.5rem 0;
      min-height: 2rem;
    }
    .status { 
      font-weight: 600; 
      padding: 0.25rem 0;
      flex: 1;
    }

    .form-label { color: #bbbbbb; font-weight: 600; }
    small { color: #999; }
    h2 { color: var(--primary); }
    
    /* Theme selector gear icon */
    .theme-selector-btn {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      color: #e0e0e0;
      padding: 0.5rem;
      cursor: pointer;
      font-size: 1.5rem;
      z-index: 1000;
      transition: transform 0.2s;
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }
    
    .theme-selector-btn:hover {
      transform: rotate(90deg);
    }
    
    /* Ensure gear icon is visible in all themes with proper contrast */
    :root.theme-manhattan .theme-selector-btn {
      color: #e0e0e0;
    }
    
    /* Manhattan theme: all buttons use the same blue color */
    :root.theme-manhattan .btn-primary,
    :root.theme-manhattan .btn-success {
      background: #3B82F6;
    }
    
    :root.theme-manhattan .btn-primary:hover,
    :root.theme-manhattan .btn-success:hover {
      background: #2563eb;
    }
    
    /* Modal styling */
    .modal-content {
      background: var(--card-bg);
      border: 1px solid var(--border);
      color: var(--text);
    }
    
    .modal-header {
      border-bottom: 1px solid var(--border);
    }
    
    .modal-title {
      color: var(--text);
    }
    
    .list-group-item {
      background: var(--input-bg);
      border-color: var(--border);
      color: var(--text);
    }
    
    .list-group-item:hover {
      background: #333;
    }
    
    .list-group-item.active {
      background: var(--primary);
      border-color: var(--primary);
    }

    /* Checkbox styling for dark theme */
    .form-check-label {
      color: var(--text);
      cursor: pointer;
    }
    .form-check-input {
      background-color: var(--input-bg);
      border-color: #444;
      cursor: pointer;
    }
    .form-check-input:checked {
      background-color: var(--primary);
      border-color: var(--primary);
    }
    .form-check-input:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);
    }
    
    /* Manhattan theme: Fix checkbox label visibility */
    :root.theme-manhattan .form-check-label {
      color: #e0e0e0 !important;
    }

    /* Custom Tooltip */
    .custom-tooltip-container {
      position: relative;
      display: inline-block;
    }
    .custom-tooltip {
      visibility: hidden;
      opacity: 0;
      background-color: var(--card-bg);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem 1.25rem;
      position: absolute;
      z-index: 1000;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      max-width: 90vw;
      font-size: 0.95rem;
      line-height: 1.5;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      transition: opacity 0.2s, visibility 0.2s;
      pointer-events: none;
    }
    .custom-tooltip::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-width: 8px;
      border-style: solid;
      border-color: var(--card-bg) transparent transparent transparent;
    }
    .custom-tooltip-container:hover .custom-tooltip {
      visibility: visible;
      opacity: 1;
    }
    
    /* Manhattan theme: Fix tooltip text visibility */
    :root.theme-manhattan .custom-tooltip {
      color: #e0e0e0 !important;
    }

    /* HIDDEN UNTIL AUTH */
    #mainUI { display: none; }

    /* PROGRESS BAR */
    .progress-container {
      margin: 1rem 0;
    }

    .progress {
      height: 25px;
      background: var(--input-bg);
      border-radius: 8px;
    }

    .progress-bar {
      background: var(--primary);
    }

    /* CodeMirror JSON Editor */
    .CodeMirror {
      background: var(--input-bg) !important;
      border: 1px solid var(--border);
      border-radius: 8px;
      height: 400px;
      font-size: 14px;
    }
    .CodeMirror-focused {
      border-color: var(--primary) !important;
    }
    
    /* Hide the textarea - CodeMirror will replace it */
    #jsonTextarea {
      display: none;
    }

    /* FACILITIES TEXTAREA */
    #facilitiesTextarea {
      min-height: 80px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div class="main-card">
    <button class="theme-selector-btn" id="themeSelectorBtn" title="Select Theme">
      <i class="fas fa-cog"></i>
    </button>
    <h2 class="text-center mb-4">Update Facility Addresses v2.2.0</h2>

    <!-- ORG -->
    <div id="authSection" class="mb-3">
      <label class="form-label">ORG:</label>
      <div class="d-flex align-items-center gap-2">
        <input type="text" id="org" class="form-control" placeholder="Enter ORG" maxlength="20" style="width: 250px; max-width: 100%;" />
        <button id="authBtn" class="btn btn-success px-4">Authenticate</button>
      </div>
      <small>Press Enter to authenticate</small>
    </div>

    <!-- STATUS -->
    <div class="status-bar">
      <div class="status" id="status">Enter ORG and press Enter to authenticate</div>
    </div>

    <!-- MAIN UI (Hidden until auth) -->
    <div id="mainUI">
      <!-- FACILITIES INPUT -->
      <div class="mb-3">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <label class="form-label mb-0">Facilities: (City, State; City, State)</label>
          <button type="button" id="clearPrefsBtn" class="btn btn-sm btn-secondary" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" title="Clear saved preferences">Clear Saved</button>
        </div>
        <textarea id="facilitiesTextarea" class="form-control" placeholder="Atlanta, GA;Jonestown, PA;Toronto, ON;Sydney, NSW"></textarea>
        <small>Enter city/state pairs separated by semicolons or commas</small>
      </div>

      <!-- UPLOAD FILE OPTION -->
      <div class="mb-3" id="uploadFileContainer" style="display: none;">
        <label class="form-label">Or upload existing JSON file:</label>
        <input type="file" id="uploadFileInput" accept=".json" class="form-control" style="width: auto;" />
        <small>File will be automatically loaded when selected</small>
      </div>

      <!-- GENERATED JSON -->
      <div class="mb-3">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <label class="form-label mb-0">Generated JSON (editable):</label>
          <button type="button" id="downloadBtn" class="btn btn-sm btn-primary" style="display: none;">Download JSON</button>
        </div>
        <textarea id="jsonTextarea" class="form-control" style="display: none;"></textarea>
        <small>You can edit the JSON before uploading</small>
      </div>

      <!-- PROGRESS -->
      <div class="progress-container">
        <div class="progress">
          <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
        </div>
        <div id="progressLabel" class="mt-2" style="font-size: 0.9em;">Ready</div>
      </div>

      <!-- BUTTONS -->
      <div class="mt-4" style="display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 1rem;">
        <div></div>
        <div class="d-flex gap-3 align-items-center">
          <button id="generateBtn" class="btn btn-success px-4" style="min-width: 200px;">Generate JSON</button>
          <button id="uploadBtn" class="btn btn-primary px-4" style="min-width: 200px;">2. Upload to WM</button>
        </div>
        <div class="form-check d-flex justify-content-start custom-tooltip-container">
          <input class="form-check-input" type="checkbox" id="resetEligibilityCheckbox" />
          <label class="form-check-label" for="resetEligibilityCheckbox" style="font-size: 0.875rem; white-space: nowrap;">Reset User Facility Eligibility?</label>
          <div class="custom-tooltip">
            This checkbox updates the Manage User Facilities for each facility listed above. For example, if this window lists 3 facilities, this checkbox will update the user to only allow these same 3 facilities.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- THEME SELECTOR MODAL -->
  <div class="modal fade" id="themeModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Select Theme</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
        </div>
        <div class="modal-body">
          <div class="list-group" id="themeList"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // DOM Elements
    const orgInput = document.getElementById('org');
    const authBtn = document.getElementById('authBtn');
    const mainUI = document.getElementById('mainUI');
    const statusEl = document.getElementById('status');
    const facilitiesTextarea = document.getElementById('facilitiesTextarea');
    const jsonTextarea = document.getElementById('jsonTextarea');
    const downloadBtn = document.getElementById('downloadBtn');
    const progressBar = document.getElementById('progressBar');
    const progressLabel = document.getElementById('progressLabel');
    const generateBtn = document.getElementById('generateBtn');
    const uploadBtn = document.getElementById('uploadBtn');
    const uploadFileContainer = document.getElementById('uploadFileContainer');
    const uploadFileInput = document.getElementById('uploadFileInput');
    const clearPrefsBtn = document.getElementById('clearPrefsBtn');
    const resetEligibilityCheckbox = document.getElementById('resetEligibilityCheckbox');

    let token = null;
    let jsonEditor = null;

    // Initialize CodeMirror editor
    function initJsonEditor() {
      if (jsonEditor) return;
      jsonEditor = CodeMirror.fromTextArea(jsonTextarea, {
        mode: { name: "javascript", json: true },
        theme: "monokai",
        lineNumbers: true,
        indentUnit: 2,
        autoCloseBrackets: true,
        matchBrackets: true,
        lineWrapping: true
      });
    }

    // Default values (when no localStorage)
    const DEFAULT_FACILITIES = "Atlanta, GA;Jonestown, PA;Toronto, ON;Sydney, NSW";
    const DEFAULT_FILENAME = "FacilityAddresses.json";

    // URL Parameters for cross-app integration
    const urlParams = new URLSearchParams(window.location.search);
    const locationParam = urlParams.get('Location');
    const organizationParam = urlParams.get('Organization');
    const businessUnitParam = urlParams.get('BusinessUnit');
    
    // Store URL parameters for use
    const urlLocation = locationParam || null;
    const urlOrg = organizationParam || null;
    const urlBusinessUnit = businessUnitParam || null;
    
    // Ensure ORG is blank on load (security) unless from URL
    if (urlOrg) {
      orgInput.value = urlOrg.trim();
      // Hide auth section when auto-authenticating
      const authSection = document.getElementById('authSection');
      if (authSection) {
        authSection.style.display = 'none';
      }
    } else {
      orgInput.value = '';
    }

    // ===== LOCALSTORAGE PERSISTENCE =====
    const STORAGE_KEY = 'facility_addresses_preferences';
    
    function savePreferences() {
      const prefs = {
        facilities: facilitiesTextarea.value,
        resetEligibilityChecked: resetEligibilityCheckbox.checked
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(prefs));
      } catch (e) {
        console.warn('Failed to save preferences:', e);
      }
    }
    
    function loadPreferences() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const prefs = JSON.parse(saved);
          if (prefs.facilities !== undefined) {
            facilitiesTextarea.value = prefs.facilities;
          } else {
            facilitiesTextarea.value = DEFAULT_FACILITIES;
          }
          // Load checkbox state (default to false if not set)
          if (prefs.resetEligibilityChecked !== undefined) {
            resetEligibilityCheckbox.checked = prefs.resetEligibilityChecked;
          } else {
            resetEligibilityCheckbox.checked = false;
          }
        } else {
          // First time - use defaults
          facilitiesTextarea.value = DEFAULT_FACILITIES;
          resetEligibilityCheckbox.checked = false;
        }
      } catch (e) {
        console.warn('Failed to load preferences:', e);
        // Use defaults on error
        facilitiesTextarea.value = DEFAULT_FACILITIES;
        resetEligibilityCheckbox.checked = false;
      }
    }
    
    function clearPreferences() {
      try {
        localStorage.removeItem(STORAGE_KEY);
        facilitiesTextarea.value = DEFAULT_FACILITIES;
        resetEligibilityCheckbox.checked = false;
        if (jsonEditor) {
          jsonEditor.setValue('');
        } else {
          jsonTextarea.value = '';
        }
        downloadBtn.style.display = 'none';
        savePreferences();
        status('Preferences cleared', 'success');
      } catch (e) {
        console.warn('Failed to clear preferences:', e);
      }
    }
    
    // Load preferences on page load
    loadPreferences();

    // Auto-save preferences
    let facilitiesTimeout;
    facilitiesTextarea.addEventListener('input', () => {
      clearTimeout(facilitiesTimeout);
      facilitiesTimeout = setTimeout(() => savePreferences(), 500);
    });

    clearPrefsBtn.addEventListener('click', () => {
      if (confirm('Clear all saved preferences? This will reset to defaults.')) {
        clearPreferences();
      }
    });

    // Save checkbox state when it changes
    resetEligibilityCheckbox.addEventListener('change', () => {
      savePreferences();
    });

    // STATUS
    function status(text, type = 'info') {
      statusEl.textContent = text;
      statusEl.className = `status text-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'}`;
    }

    // API
    async function api(action, data = {}) {
      // If in preview mode, return mock success responses
      if (token === 'preview-token') {
        console.log(`[Preview] Mock API call: ${action}`, data);
        return Promise.resolve({ success: true, message: 'Preview mode - no actual API call' });
      }
      
      const headers = { 'Content-Type': 'application/json' };
      if (token) headers.Authorization = `Bearer ${token}`;
      return fetch(`/api/${action}`, {
        method: 'POST',
        headers,
        body: JSON.stringify(data)
      }).then(r => r.json());
    }

    // ===== SESSION TRACKING =====
    const SESSION_STORAGE_KEY = 'facility_addresses_session';
    let sessionId = null;
    let pageLoadTime = null;
    let authAttemptCount = 0;
    let firstAuthSuccess = true;

    // Initialize session on page load
    (function initSession() {
      pageLoadTime = Date.now();
      
      // Get or create session ID
      sessionId = sessionStorage.getItem(SESSION_STORAGE_KEY);
      if (!sessionId) {
        sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substring(2, 15);
        sessionStorage.setItem(SESSION_STORAGE_KEY, sessionId);
      }
      
      // Check if returning user
      const hasSavedPreferences = localStorage.getItem('facility_addresses_facilities') !== null;
      
      // Store for metadata collection
      window._appSession = {
        sessionId,
        pageLoadTime,
        hasSavedPreferences
      };
    })();

    // ===== GENERIC METADATA COLLECTION (Reusable across all apps) =====
    function getCommonMetadata(additionalMetadata = {}) {
      const now = Date.now();
      const timeOnPage = pageLoadTime ? Math.floor((now - pageLoadTime) / 1000) : 0;
      
      // Parse user agent
      const ua = navigator.userAgent;
      const browserInfo = parseUserAgent(ua);
      
      // Get screen info
      const screenWidth = window.screen.width;
      const screenHeight = window.screen.height;
      const screenResolution = `${screenWidth}x${screenHeight}`;
      
      // Get URL parameters
      const urlParamsObj = {};
      const currentUrlParams = new URLSearchParams(window.location.search);
      for (const [key, value] of currentUrlParams.entries()) {
        urlParamsObj[key] = value;
      }
      
      // Get theme
      const currentTheme = localStorage.getItem('facility_addresses_theme') || 'dark';
      
      // Check for preview mode
      const previewMode = urlParamsObj.preview === 'true';
      
      // Build common metadata
      const commonMetadata = {
        // Category 1: User/Browser Information
        user_agent: ua,
        browser_name: browserInfo.name,
        browser_version: browserInfo.version,
        device_type: getDeviceType(),
        os_name: browserInfo.os,
        os_version: browserInfo.osVersion,
        screen_resolution: screenResolution,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        language: navigator.language || navigator.userLanguage,
        
        // Category 2: Session & Context
        session_id: sessionId,
        page_load_time: pageLoadTime ? new Date(pageLoadTime).toISOString() : null,
        time_on_page: timeOnPage,
        referrer: document.referrer || null,
        url_params: Object.keys(urlParamsObj).length > 0 ? urlParamsObj : null,
        auto_authenticated: false, // This app doesn't use URL params for auto-auth
        preview_mode: previewMode,
        
        // Category 3: App State & Preferences
        theme: currentTheme,
        has_saved_preferences: window._appSession?.hasSavedPreferences || false,
        
        // Category 4: Authentication Context (will be overridden by event-specific data)
        auth_method: 'manual',
        auth_attempt_count: authAttemptCount,
        first_auth_success: firstAuthSuccess,
        
        // Category 7: Error & Debugging (will be populated if error occurs)
        // error_code, error_message, stack_trace, api_error_details - added per event
        
        // Category 8: Cross-App Integration
        source_app: null,
        integration_type: 'direct',
        
        // Category 10: Geographic/Network
        request_origin: window.location.origin,
        
        // Merge any additional metadata
        ...additionalMetadata
      };
      
      return commonMetadata;
    }

    // Helper: Parse user agent
    function parseUserAgent(ua) {
      let name = 'Unknown';
      let version = 'Unknown';
      let os = 'Unknown';
      let osVersion = 'Unknown';
      
      // Browser detection
      if (ua.includes('Chrome') && !ua.includes('Edg')) {
        name = 'Chrome';
        const match = ua.match(/Chrome\/([\d.]+)/);
        version = match ? match[1] : 'Unknown';
      } else if (ua.includes('Firefox')) {
        name = 'Firefox';
        const match = ua.match(/Firefox\/([\d.]+)/);
        version = match ? match[1] : 'Unknown';
      } else if (ua.includes('Safari') && !ua.includes('Chrome')) {
        name = 'Safari';
        const match = ua.match(/Version\/([\d.]+)/);
        version = match ? match[1] : 'Unknown';
      } else if (ua.includes('Edg')) {
        name = 'Edge';
        const match = ua.match(/Edg\/([\d.]+)/);
        version = match ? match[1] : 'Unknown';
      }
      
      // OS detection
      if (ua.includes('Windows')) {
        os = 'Windows';
        const match = ua.match(/Windows NT ([\d.]+)/);
        if (match) {
          const ntVersion = match[1];
          const versionMap = {
            '10.0': '10/11',
            '6.3': '8.1',
            '6.2': '8',
            '6.1': '7'
          };
          osVersion = versionMap[ntVersion] || ntVersion;
        }
      } else if (ua.includes('Mac OS X') || ua.includes('Macintosh')) {
        os = 'macOS';
        const match = ua.match(/Mac OS X ([\d_]+)/);
        if (match) {
          osVersion = match[1].replace(/_/g, '.');
        }
      } else if (ua.includes('Linux')) {
        os = 'Linux';
      } else if (ua.includes('Android')) {
        os = 'Android';
        const match = ua.match(/Android ([\d.]+)/);
        osVersion = match ? match[1] : 'Unknown';
      } else if (ua.includes('iPhone') || ua.includes('iPad')) {
        os = 'iOS';
        const match = ua.match(/OS ([\d_]+)/);
        if (match) {
          osVersion = match[1].replace(/_/g, '.');
        }
      }
      
      return { name, version, os, osVersion };
    }

    // Helper: Get device type
    function getDeviceType() {
      const ua = navigator.userAgent;
      if (/tablet|ipad|playbook|silk/i.test(ua)) {
        return 'tablet';
      }
      if (/mobile|iphone|ipod|android|blackberry|opera|mini|windows\sce|palm|smartphone|iemobile/i.test(ua)) {
        return 'mobile';
      }
      return 'desktop';
    }

    // Home Assistant tracking helper with enhanced metadata
    async function trackEvent(eventName, metadata = {}) {
      try {
        // Get common metadata and merge with event-specific metadata
        const fullMetadata = getCommonMetadata(metadata);
        
        await api('ha-track', {
          event_name: eventName,
          metadata: fullMetadata
        });
      } catch (error) {
        // Silently fail - don't interrupt user experience
        console.warn('[HA] Failed to track event:', error);
      }
    }

    // App opened
    window.addEventListener('load', () => {
      // Check for preview mode (for local testing without backend)
      const urlParams = new URLSearchParams(window.location.search);
      const previewMode = urlParams.get('preview') === 'true';
      
      // Track app opened with full metadata
      trackEvent('app_opened', {});
      
      if (previewMode) {
        // Simulate authentication for preview
        token = 'preview-token';
        mainUI.style.display = 'block';
        uploadFileContainer.style.display = 'block';
        status('Preview Mode - UI visible (no API calls)', 'info');
        orgInput.value = 'SS-DEMO';
      } else {
        api('app_opened', {}).catch(() => {
          // Silently fail if API not available
        });
      }
      
      orgInput.focus();
      initJsonEditor();
    });

    // Auth
    async function authenticate() {
      const org = orgInput.value.trim();
      if (!org) {
        status('ORG required', 'error');
        mainUI.style.display = 'none';
        return;
      }
      
      // Increment auth attempt count
      authAttemptCount++;
      const authStartTime = Date.now();
      
      // Track auth attempt
      trackEvent('auth_attempt', {
        org: org || 'unknown',
        auth_attempt_count: authAttemptCount
      });
      
      status('Authenticating...');
      
      // Check for preview mode
      const urlParams = new URLSearchParams(window.location.search);
      const previewMode = urlParams.get('preview') === 'true';
      
      if (previewMode) {
        // Simulate successful auth for preview
        token = 'preview-token';
        status('Preview Mode - Authenticated (no API call)', 'success');
        mainUI.style.display = 'block';
        uploadFileContainer.style.display = 'block';
        
        // Track preview mode auth success
        trackEvent('auth_success', {
          org: org || 'unknown',
          auth_attempt_count: authAttemptCount,
          auth_duration_ms: Date.now() - authStartTime,
          token_received: true,
          first_auth_success: firstAuthSuccess,
          preview_mode: true
        });
        firstAuthSuccess = false;
        return;
      }
      
      const res = await api('auth', { org });
      const authDuration = Date.now() - authStartTime;
      
      if (!res.success) {
        // Track auth failure
        trackEvent('auth_failed', {
          org: org || 'unknown',
          error: res.error || 'Auth failed',
          error_message: res.error || 'Auth failed',
          auth_attempt_count: authAttemptCount,
          auth_duration_ms: authDuration,
          token_received: false
        });
        firstAuthSuccess = false;
        
        status(res.error || 'Auth failed', 'error');
        mainUI.style.display = 'none';
        return;
      }
      
      token = res.token;
      status('Authenticated â€“ ready!', 'success');
      
      // Track auth success
      trackEvent('auth_success', {
        org: org,
        auth_attempt_count: authAttemptCount,
        auth_duration_ms: authDuration,
        token_received: true,
        first_auth_success: firstAuthSuccess
      });
      
      // Reset for next session (if they log out and back in)
      firstAuthSuccess = false;
      
      mainUI.style.display = 'block';
      uploadFileContainer.style.display = 'block';
    }

    orgInput.addEventListener('keypress', e => {
      if (e.key === 'Enter') authenticate();
    });
    authBtn.onclick = authenticate;

    // Generate JSON with progress updates
    generateBtn.onclick = async () => {
      if (!token) return status('Authenticate first', 'error');
      
      const facilities = facilitiesTextarea.value.trim();
      if (!facilities) return status('Enter facilities', 'error');
      
      const org = orgInput.value.trim();
      if (!org) return status('ORG required', 'error');
      
      // Validate and parse facilities - handle both semicolon and comma separators
      // First split by semicolon to get pairs, then split each pair by comma
      let facilities_list = [];
      const pairs = facilities.split(';').map(p => p.trim()).filter(p => p);
      
      // Parse facilities for metadata
      const facilityPairs = [];
      for (let i = 0; i < pairs.length; i++) {
        const parts = pairs[i].split(',').map(p => p.trim()).filter(p => p);
        if (parts.length === 2) {
          facilityPairs.push([parts[0], parts[1]]);
        }
      }
      
      const generateStartTime = Date.now();
      
      // Track generate attempt with facility addresses specific metadata
      trackEvent('generate_addresses_attempt', {
        org: org || 'unknown',
        facilities_input: facilities,
        facilities_input_length: String(facilities.length),
        facility_pairs_count: facilityPairs.length,
        facility_list: facilityPairs.length > 0 ? facilityPairs : null
      });
      
      // Validation: Check each pair
      const validationErrors = [];
      
      if (pairs.length === 0) {
        status('No facilities found. Use format: "City, State; City, State"', 'error');
        
        // Track generation failure
        trackEvent('generate_addresses_failed', {
          org: org || 'unknown',
          facilities_input: facilities,
          facilities_input_length: String(facilities.length),
          facility_pairs_count: 0,
          validation_errors_count: 1,
          has_validation_errors: true,
          error: 'No facilities found',
          error_message: 'No facilities found. Use format: "City, State; City, State"'
        });
        return;
      }
      
      for (let i = 0; i < pairs.length; i++) {
        const pair = pairs[i];
        const parts = pair.split(',').map(p => p.trim()).filter(p => p);
        
        if (parts.length === 0) {
          validationErrors.push(`Pair ${i + 1} is empty`);
        } else if (parts.length === 1) {
          validationErrors.push(`Pair ${i + 1} ("${pair}") is missing state. Use format: "City, State"`);
        } else if (parts.length > 2) {
          // More than 2 parts - likely has extra commas (e.g., "New York, New York, USA")
          validationErrors.push(`Pair ${i + 1} ("${pair}") has too many commas. Use format: "City, State" (no country or extra info)`);
        } else {
          // Valid pair - exactly 2 parts
          const city = parts[0];
          const state = parts[1];
          
          if (!city) {
            validationErrors.push(`Pair ${i + 1} is missing city name`);
          } else if (!state) {
            validationErrors.push(`Pair ${i + 1} ("${city}") is missing state`);
          } else {
            facilities_list.push(city, state);
          }
        }
      }
      
      // If no semicolons found, try splitting by comma only (legacy format)
      if (facilities_list.length === 0 && pairs.length === 1 && !validationErrors.length) {
        const commaParts = facilities.split(',').map(f => f.trim()).filter(f => f);
        if (commaParts.length % 2 === 0) {
          facilities_list = commaParts;
        } else {
          validationErrors.push('Invalid format. Use semicolons to separate pairs: "City, State; City, State"');
        }
      }
      
      // Show validation errors if any
      if (validationErrors.length > 0) {
        const errorMsg = 'Validation errors:\n' + validationErrors.map((e, idx) => `${idx + 1}. ${e}`).join('\n');
        status(errorMsg, 'error');
        return;
      }
      
      // Final check: must have even number of items (pairs)
      if (facilities_list.length % 2 !== 0) {
        status('Facilities must be in pairs (City, State). Use format: "City, State; City, State"', 'error');
        
        // Track generation failure
        trackEvent('generate_addresses_failed', {
          org: org || 'unknown',
          facilities_input: facilities,
          facilities_input_length: String(facilities.length),
          facility_pairs_count: facilityPairs.length,
          validation_errors_count: 1,
          has_validation_errors: true,
          error: 'Invalid pair count',
          error_message: 'Facilities must be in pairs (City, State). Use format: "City, State; City, State"'
        });
        return;
      }
      
      if (facilities_list.length === 0) {
        status('No valid facilities found. Use format: "City, State; City, State"', 'error');
        
        // Track generation failure
        trackEvent('generate_addresses_failed', {
          org: org || 'unknown',
          facilities_input: facilities,
          facilities_input_length: String(facilities.length),
          facility_pairs_count: 0,
          validation_errors_count: 1,
          has_validation_errors: true,
          error: 'No valid facilities',
          error_message: 'No valid facilities found. Use format: "City, State; City, State"'
        });
        return;
      }

      status('Generating addresses...', 'info');
      generateBtn.disabled = true;
      progressBar.style.width = '0%';
      progressLabel.textContent = 'Starting...';

      const results = [];
      const total_pairs = facilities_list.length / 2;
      let geocodingSuccessCount = 0;
      let geocodingFailedCount = 0;
      let stateCorrectionsCount = 0;
      const geocodingErrors = [];
      const geocodingStartTime = Date.now();
      let geocodingApiCallsCount = 0;
      const facilityIds = [];
      const countriesList = [];
      const statesList = [];

      try {
        // Geocode each pair individually to show progress
        for (let i = 0; i < facilities_list.length; i += 2) {
          const city = facilities_list[i];
          const state = facilities_list[i + 1];
          const pair_num = (i / 2) + 1;
          
          progressLabel.textContent = `Geocoding ${city}, ${state} (${pair_num}/${total_pairs})...`;
          progressBar.style.width = `${((i / 2) / total_pairs) * 100}%`;
          
          const geoStartTime = Date.now();
          const geoRes = await api('geocode', { city, state });
          geocodingApiCallsCount++;
          const geoDuration = Date.now() - geoStartTime;
          
          if (!geoRes.success) {
            status(`Error geocoding ${city}, ${state}: ${geoRes.error}`, 'error');
            geocodingFailedCount++;
            geocodingErrors.push({ city, state, error: geoRes.error });
            generateBtn.disabled = false;
            
            // Track generation failure
            const generationDuration = Date.now() - generateStartTime;
            const geocodingDuration = Date.now() - geocodingStartTime;
            trackEvent('generate_addresses_failed', {
              org: org || 'unknown',
              facilities_input: facilities,
              facilities_input_length: String(facilities.length),
              facility_pairs_count: total_pairs,
              geocoding_pairs_count: total_pairs,
              geocoding_success_count: geocodingSuccessCount,
              geocoding_failed_count: geocodingFailedCount,
              geocoding_errors: geocodingErrors.length > 0 ? geocodingErrors : null,
              geocoding_api_calls_count: geocodingApiCallsCount,
              generation_duration_ms: generationDuration,
              geocoding_duration_ms: geocodingDuration,
              error: geoRes.error || 'Geocoding failed',
              error_message: `Error geocoding ${city}, ${state}: ${geoRes.error}`
            });
            return;
          }
          
          geocodingSuccessCount++;
          
          const geo_result = geoRes.result;
          // Use corrected state from geocoding
          const corrected_state = geo_result.state || state;
          
          // Check if state was corrected
          if (geo_result.state && geo_result.state !== state) {
            stateCorrectionsCount++;
          }
          
          // Track unique countries and states
          if (geo_result.country && !countriesList.includes(geo_result.country)) {
            countriesList.push(geo_result.country);
          }
          if (corrected_state && !statesList.includes(corrected_state)) {
            statesList.push(corrected_state);
          }
          
          const facilityId = `${org}-DM${pair_num}`;
          facilityIds.push(facilityId);
          
          const entry = {
            "FacilityId": facilityId,
            "FacilityAddress": {
              "Address1": geo_result.address,
              "City": city,
              "State": corrected_state,
              "PostalCode": geo_result.zip_code,
              "Country": geo_result.country
            },
            "Latitude": `${geo_result.lat.toFixed(5)}`,
            "Longitude": `${geo_result.lng.toFixed(5)}`,
            "Description": `${city}-DC`,
            "DmDeployed": "true"
          };
          results.push(entry);
          
          // Update progress after completion
          progressBar.style.width = `${(pair_num / total_pairs) * 100}%`;
          progressLabel.textContent = `Completed ${city}, ${state} (${pair_num}/${total_pairs})`;
          
          // Rate limiting delay (except for last item)
          if (i < facilities_list.length - 2) {
            await new Promise(resolve => setTimeout(resolve, 1100));
          }
        }

        // Display JSON in editor
        const jsonData = { "Data": results };
        const jsonStr = JSON.stringify(jsonData, null, 4);
        const jsonSizeBytes = new Blob([jsonStr]).size;
        if (jsonEditor) {
          jsonEditor.setValue(jsonStr);
        } else {
          jsonTextarea.value = jsonStr;
        }
        downloadBtn.style.display = 'inline-block';
        
        progressBar.style.width = '100%';
        progressLabel.textContent = `Generated ${total_pairs} facility addresses`;
        status(`Generated ${total_pairs} facility addresses!`, 'success');
        
        // Track generation success with facility addresses specific metadata
        const generationDuration = Date.now() - generateStartTime;
        const geocodingDuration = Date.now() - geocodingStartTime;
        trackEvent('generate_addresses_completed', {
          org: org || 'unknown',
          facilities_input: facilities,
          facilities_input_length: String(facilities.length),
          facility_pairs_count: total_pairs,
          facility_count: results.length,
          facility_ids: facilityIds.length > 0 ? facilityIds : null,
          countries_list: countriesList.length > 0 ? countriesList : null,
          states_list: statesList.length > 0 ? statesList : null,
          geocoding_pairs_count: total_pairs,
          geocoding_success_count: geocodingSuccessCount,
          geocoding_failed_count: geocodingFailedCount,
          geocoding_api_calls_count: geocodingApiCallsCount,
          state_corrections_count: stateCorrectionsCount,
          json_size_bytes: jsonSizeBytes,
          json_length: String(jsonStr.length),
          generation_duration_ms: generationDuration,
          geocoding_duration_ms: geocodingDuration
        });
      } catch (e) {
        status(`Error: ${e.message}`, 'error');
        progressLabel.textContent = 'Generation failed';
        
        // Track generation failure
        const generationDuration = Date.now() - generateStartTime;
        trackEvent('generate_addresses_failed', {
          org: org || 'unknown',
          facilities_input: facilities,
          facilities_input_length: String(facilities.length),
          facility_pairs_count: total_pairs,
          geocoding_success_count: geocodingSuccessCount,
          geocoding_failed_count: geocodingFailedCount,
          geocoding_errors: geocodingErrors.length > 0 ? geocodingErrors : null,
          generation_duration_ms: generationDuration,
          error: e.message || 'Unknown error',
          error_message: e.message || 'Unknown error'
        });
      } finally {
        generateBtn.disabled = false;
      }
    };

    // Download JSON
    downloadBtn.onclick = () => {
      const jsonStr = jsonEditor ? jsonEditor.getValue().trim() : jsonTextarea.value.trim();
      if (!jsonStr) {
        status('No JSON to download', 'error');
        return;
      }

      const org = orgInput.value.trim() || 'unknown';
      const jsonSizeBytes = new Blob([jsonStr]).size;
      
      // Parse JSON to get facility count
      let facilityCount = 0;
      try {
        const jsonData = JSON.parse(jsonStr);
        if (Array.isArray(jsonData?.Data)) {
          facilityCount = jsonData.Data.length;
        } else if (Array.isArray(jsonData)) {
          facilityCount = jsonData.length;
        }
      } catch (e) {
        // Will be caught below
      }
      
      // Track download attempt with facility addresses specific metadata
      trackEvent('download_json_attempt', {
        org: org,
        json_length: String(jsonStr.length),
        json_size_bytes: jsonSizeBytes,
        facility_count: facilityCount,
        file_name: DEFAULT_FILENAME
      });

      try {
        // Validate JSON
        JSON.parse(jsonStr);
        
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = DEFAULT_FILENAME;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        status('File downloaded!', 'success');
        
        // Track download success with facility addresses specific metadata
        trackEvent('download_json_completed', {
          org: org,
          json_length: String(jsonStr.length),
          json_size_bytes: jsonSizeBytes,
          facility_count: facilityCount,
          file_name: DEFAULT_FILENAME,
          json_valid: true
        });
      } catch (e) {
        status('Invalid JSON - cannot download', 'error');
        
        // Track download failure with facility addresses specific metadata
        trackEvent('download_json_failed', {
          org: org,
          json_length: String(jsonStr.length),
          json_size_bytes: jsonSizeBytes,
          error: e.message || 'Unknown error',
          error_message: e.message || 'Unknown error',
          json_valid: false
        });
      }
    };

    // Auto-load uploaded file when selected
    uploadFileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) {
        return;
      }

      const org = orgInput.value.trim() || 'unknown';
      
      // Track load JSON file attempt with facility addresses specific metadata
      trackEvent('load_json_file_attempt', {
        org: org,
        file_name: file.name,
        file_size_bytes: file.size
      });

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const jsonStr = e.target.result;
          const jsonSizeBytes = new Blob([jsonStr]).size;
          
          // Validate and format JSON
          const jsonObj = JSON.parse(jsonStr);
          
          // Get facility count
          let facilityCount = 0;
          if (Array.isArray(jsonObj?.Data)) {
            facilityCount = jsonObj.Data.length;
          } else if (Array.isArray(jsonObj)) {
            facilityCount = jsonObj.length;
          }
          
          const formattedJson = JSON.stringify(jsonObj, null, 4);
          if (jsonEditor) {
            jsonEditor.setValue(formattedJson);
          } else {
            jsonTextarea.value = formattedJson;
          }
          downloadBtn.style.display = 'inline-block';
          status('File loaded into editor', 'success');
          
          // Track load JSON file success with facility addresses specific metadata
          trackEvent('load_json_file_completed', {
            org: org,
            file_name: file.name,
            file_size_bytes: file.size,
            json_length: String(jsonStr.length),
            json_size_bytes: jsonSizeBytes,
            facility_count: facilityCount,
            json_valid: true
          });
        } catch (e) {
          status('Invalid JSON file: ' + e.message, 'error');
          uploadFileInput.value = ''; // Clear the invalid file selection
          
          // Track load JSON file failure with facility addresses specific metadata
          trackEvent('load_json_file_failed', {
            org: org,
            file_name: file.name,
            file_size_bytes: file.size,
            error: e.message || 'Unknown error',
            error_message: e.message || 'Unknown error',
            json_valid: false
          });
        }
      };
      reader.onerror = () => {
        status('Error reading file', 'error');
        uploadFileInput.value = '';
        
        // Track load JSON file failure with facility addresses specific metadata
        trackEvent('load_json_file_failed', {
          org: org,
          file_name: file.name,
          file_size_bytes: file.size,
          error: 'Error reading file',
          error_message: 'Error reading file',
          json_valid: false
        });
      };
      reader.readAsText(file);
    });

    // Upload to WM
    uploadBtn.onclick = async () => {
      if (!token) return status('Authenticate first', 'error');
      
      const jsonStr = jsonEditor ? jsonEditor.getValue().trim() : jsonTextarea.value.trim();
      if (!jsonStr) {
        status('No JSON to upload. Generate or load JSON first.', 'error');
        return;
      }

      // Validate JSON
      let jsonData;
      try {
        jsonData = JSON.parse(jsonStr);
      } catch (e) {
        status('Invalid JSON format', 'error');
        return;
      }

      const org = orgInput.value.trim();
      if (!org) return status('ORG required', 'error');

      // Parse JSON to get facility count and location IDs
      let facilityCount = 0;
      let locationIds = [];
      try {
        if (Array.isArray(jsonData?.Data)) {
          facilityCount = jsonData.Data.length;
          locationIds = jsonData.Data
            .map(item => item && item.FacilityId)
            .filter(id => typeof id === 'string' && id.trim().length > 0);
        } else if (Array.isArray(jsonData)) {
          facilityCount = jsonData.length;
          locationIds = jsonData
            .map(item => item && item.FacilityId)
            .filter(id => typeof id === 'string' && id.trim().length > 0);
        }
      } catch (e) {
        // If anything goes wrong, fall back to defaults
      }
      
      const jsonSizeBytes = new Blob([jsonStr]).size;
      const resetEligibilityChecked = resetEligibilityCheckbox?.checked || false;
      const uploadStartTime = Date.now();
      
      // Track upload attempt with facility addresses specific metadata
      trackEvent('upload_addresses_attempt', {
        org: org || 'unknown',
        json_length: String(jsonStr.length),
        json_size_bytes: jsonSizeBytes,
        facility_count: facilityCount,
        location_ids_count: locationIds.length,
        reset_eligibility_checked: resetEligibilityChecked
      });

      status('Uploading...', 'info');
      uploadBtn.disabled = true;
      progressBar.style.width = '0%';
      progressLabel.textContent = 'Uploading...';

      try {
        const apiStartTime = Date.now();
        const res = await api('upload', { org, token, json_data: jsonData });
        const uploadApiResponseTime = Date.now() - apiStartTime;
        const uploadDuration = Date.now() - uploadStartTime;
        
        progressBar.style.width = '100%';
        
        if (!res.success) {
          status(res.error || 'Upload failed', 'error');
          progressLabel.textContent = 'Upload Failed';
          
          // Track upload failure with facility addresses specific metadata
          trackEvent('upload_addresses_failed', {
            org: org || 'unknown',
            json_length: String(jsonStr.length),
            json_size_bytes: jsonSizeBytes,
            facility_count: facilityCount,
            reset_eligibility_checked: resetEligibilityChecked,
            upload_duration_ms: uploadDuration,
            upload_api_response_time_ms: uploadApiResponseTime,
            upload_success: false,
            error: res.error || 'Upload failed',
            error_message: res.error || 'Upload failed'
          });
          
          return;
        }

        let finalStatusMessage = 'Upload complete!';
        let finalProgressLabel = `Upload Complete: ${res.summary}`;
        let alertMessage = res.summary;

        // If requested, perform the additional reset user eligibility call
        if (resetEligibilityCheckbox && resetEligibilityCheckbox.checked) {
          // Derive LocationIds from the JSON payload currently displayed
          let locationIds = [];
          try {
            if (Array.isArray(jsonData?.Data)) {
              locationIds = jsonData.Data
                .map(item => item && item.FacilityId)
                .filter(id => typeof id === 'string' && id.trim().length > 0);
            } else if (Array.isArray(jsonData)) {
              locationIds = jsonData
                .map(item => item && item.FacilityId)
                .filter(id => typeof id === 'string' && id.trim().length > 0);
            }
          } catch (e) {
            // If anything goes wrong, fall back to no locations
            locationIds = [];
          }

          if (locationIds.length > 0) {
            const resetRes = await api('reset_user_eligibility', {
              org,
              token,
              location_ids: locationIds
            });

            if (!resetRes.success) {
              finalStatusMessage = 'Upload complete, but user eligibility reset failed';
              finalProgressLabel += ' | User eligibility reset failed';
              alertMessage += `\n\nUser eligibility reset failed: ${resetRes.error || 'Unknown error'}`;
            } else {
              finalStatusMessage = 'Upload complete and user eligibility reset!';
              finalProgressLabel += ' | User eligibility reset';
              if (resetRes.summary) {
                alertMessage += `\n\nUser eligibility reset:\n${resetRes.summary}`;
              } else {
                alertMessage += `\n\nUser eligibility reset completed.`;
              }
            }
          } else {
            finalStatusMessage = 'Upload complete, but no FacilityIds found for user eligibility reset';
            finalProgressLabel += ' | No FacilityIds for reset';
            alertMessage += `\n\nNo FacilityIds found in JSON for user eligibility reset.`;
          }
        }

        progressLabel.textContent = finalProgressLabel;
        status(finalStatusMessage, 'success');
        
        // Track upload success with facility addresses specific metadata
        trackEvent('upload_addresses_completed', {
          org: org || 'unknown',
          json_length: String(jsonStr.length),
          json_size_bytes: jsonSizeBytes,
          facility_count: facilityCount,
          location_ids_count: locationIds.length,
          reset_eligibility_checked: resetEligibilityChecked,
          reset_eligibility_attempted: resetEligibilityAttempted,
          reset_eligibility_success: resetEligibilityAttempted ? resetEligibilitySuccess : null,
          upload_duration_ms: uploadDuration,
          upload_api_response_time_ms: uploadApiResponseTime,
          upload_success: true,
          upload_total: res.total || facilityCount,
          upload_success_count: res.success || facilityCount,
          upload_failed_count: res.failed || 0,
          upload_summary: res.summary || null
        });
        
        // Show summary in alert
        alert(alertMessage);
      } catch (e) {
        status(`Error: ${e.message}`, 'error');
        progressLabel.textContent = 'Upload Failed';
        
        // Track upload failure with facility addresses specific metadata
        trackEvent('upload_addresses_failed', {
          org: org || 'unknown',
          json_length: String(jsonStr.length),
          json_size_bytes: jsonSizeBytes,
          facility_count: facilityCount,
          reset_eligibility_checked: resetEligibilityChecked,
          upload_duration_ms: Date.now() - uploadStartTime,
          upload_success: false,
          error: e.message || 'Unknown error',
          error_message: e.message || 'Unknown error'
        });
      } finally {
        uploadBtn.disabled = false;
      }
    };

    // ===== THEME SYSTEM =====
    const THEME_STORAGE_KEY = 'facility_addresses_theme';
    const themeSelectorBtn = document.getElementById('themeSelectorBtn');
    let themeModal = null;
    const themeList = document.getElementById('themeList');

    // Initialize Bootstrap modal after DOM is ready
    if (typeof bootstrap !== 'undefined') {
      const modalElement = document.getElementById('themeModal');
      if (modalElement) {
        themeModal = new bootstrap.Modal(modalElement);
      }
    }

    const themes = {
      dark: {
        name: 'Dark',
        rootClass: 'theme-dark'
      },
      manhattan: {
        name: 'Manhattan',
        rootClass: 'theme-manhattan'
      }
    };

    // Load saved theme or default to dark
    function loadTheme() {
      const savedTheme = localStorage.getItem(THEME_STORAGE_KEY) || 'dark';
      applyTheme(savedTheme);
    }

    // Apply theme
    function applyTheme(themeName) {
      const root = document.documentElement;
      const theme = themes[themeName] || themes.dark;
      
      // Remove all theme classes
      Object.values(themes).forEach(t => {
        if (t.rootClass) {
          root.classList.remove(t.rootClass);
        }
      });
      
      // Apply selected theme
      if (theme.rootClass) {
        root.classList.add(theme.rootClass);
      }
      
      // Save to localStorage
      localStorage.setItem(THEME_STORAGE_KEY, themeName);
    }

    // Render theme list in modal
    function renderThemeList() {
      if (!themeList) return;
      themeList.innerHTML = '';
      const currentTheme = localStorage.getItem(THEME_STORAGE_KEY) || 'dark';
      
      Object.entries(themes).forEach(([key, theme]) => {
        const item = document.createElement('button');
        item.type = 'button';
        item.className = `list-group-item list-group-item-action ${key === currentTheme ? 'active' : ''}`;
        item.textContent = theme.name;
        item.onclick = () => {
          applyTheme(key);
          if (themeModal) {
            themeModal.hide();
          }
        };
        themeList.appendChild(item);
      });
    }

    // Theme selector button click handler
    if (themeSelectorBtn) {
      themeSelectorBtn.onclick = () => {
        renderThemeList();
        if (themeModal) {
          themeModal.show();
        }
      };
      
      // Ensure button is always visible after theme changes
      const observer = new MutationObserver(() => {
        if (themeSelectorBtn) {
          themeSelectorBtn.style.display = 'block';
          themeSelectorBtn.style.visibility = 'visible';
        }
      });
      
      // Observe theme class changes on root element
      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class']
      });
    }

    // Load theme on page load
    loadTheme();

    // Ensure gear icon is visible after theme loads
    if (themeSelectorBtn) {
      setTimeout(() => {
        themeSelectorBtn.style.display = 'block';
        themeSelectorBtn.style.visibility = 'visible';
      }, 100);
    }
  </script>
  <!-- Vercel Analytics -->
  <script>
    (function() {
      const script = document.createElement('script');
      script.src = '/_vercel/insights/script.js';
      script.defer = true;
      script.onerror = function() {
        console.warn('Vercel Analytics script failed to load. Make sure Analytics is enabled in Vercel dashboard and the app is redeployed.');
      };
      document.head.appendChild(script);
    })();
  </script>
</body>
</html>

