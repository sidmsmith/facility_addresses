<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Site Identification Developer v2.1.0</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <!-- CodeMirror for JSON syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/monokai.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/json/json.min.js"></script>
  <style>
    :root {
      --bg-dark: #121212;
      --card-bg: #1e1e1e;
      --input-bg: #2d2d2d;
      --border: #333;
      --text: #e0e0e0;
      --red-bg: #4a1a1a;
      --red-text: #ff6b6b;
      --blue-select: #339af0;
      --success: #28a745;
      --primary: #0d6efd;
    }

    body { 
      background: var(--bg-dark); 
      color: var(--text); 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      min-height: 100vh;
      margin: 0;
    }

    .main-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      padding: 1.5rem;
      margin: 1rem;
      display: flex;
      flex-direction: column;
    }

    @media (min-width: 769px) {
      .main-card { max-width: 900px; margin: 2rem auto; }
    }

    .form-control, .form-select, textarea {
      background: var(--input-bg);
      border: 1px solid #444;
      color: #fff;
      border-radius: 8px;
    }
    .form-control:focus, .form-select:focus, textarea:focus {
      background: #333;
      border-color: var(--primary);
      box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);
      color: #fff;
    }

    .btn-primary { background: var(--primary); border: none; }
    .btn-success { background: var(--success); border: none; }
    .btn-secondary { background: #6c757d; border: none; }
    .btn-primary:hover { background: #0b5ed7; }
    .btn-success:hover { background: #218838; }
    .btn-secondary:hover { background: #5a6268; }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 1rem 0 0.5rem 0;
      min-height: 2rem;
    }
    .status { 
      font-weight: 600; 
      padding: 0.25rem 0;
      flex: 1;
    }

    .form-label { color: #bbbbbb; font-weight: 600; }
    small { color: #999; }
    h2 { color: var(--primary); }

    /* HIDDEN UNTIL AUTH */
    #mainUI { display: none; }

    /* PROGRESS BAR */
    .progress-container {
      margin: 1rem 0;
    }

    .progress {
      height: 25px;
      background: var(--input-bg);
      border-radius: 8px;
    }

    .progress-bar {
      background: var(--primary);
    }

    /* CodeMirror JSON Editor */
    .CodeMirror {
      background: var(--input-bg) !important;
      border: 1px solid var(--border);
      border-radius: 8px;
      height: 400px;
      font-size: 14px;
    }
    .CodeMirror-focused {
      border-color: var(--primary) !important;
    }
    
    /* Hide the textarea - CodeMirror will replace it */
    #jsonTextarea {
      display: none;
    }

    /* FACILITIES TEXTAREA */
    #facilitiesTextarea {
      min-height: 80px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div class="main-card">
    <h2 class="text-center mb-4">Site Identification Developer v2.0.0</h2>

    <!-- ORG -->
    <div class="mb-3">
      <label class="form-label">ORG:</label>
      <div class="d-flex align-items-center gap-2">
        <input type="text" id="org" class="form-control" placeholder="Enter ORG" maxlength="20" style="width: 250px; max-width: 100%;" />
        <button id="authBtn" class="btn btn-success px-4">Authenticate</button>
      </div>
      <small>Press Enter to authenticate</small>
    </div>

    <!-- STATUS -->
    <div class="status-bar">
      <div class="status" id="status">Enter ORG and press Enter to authenticate</div>
    </div>

    <!-- MAIN UI (Hidden until auth) -->
    <div id="mainUI">
      <!-- FACILITIES INPUT -->
      <div class="mb-3">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <label class="form-label mb-0">Facilities: (City, State; City, State)</label>
          <button type="button" id="clearPrefsBtn" class="btn btn-sm btn-secondary" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;" title="Clear saved preferences">Clear Saved</button>
        </div>
        <textarea id="facilitiesTextarea" class="form-control" placeholder="Atlanta, GA;Jonestown, PA;Toronto, ON;Sydney, NSW"></textarea>
        <small>Enter city/state pairs separated by semicolons or commas</small>
      </div>

      <!-- UPLOAD FILE OPTION -->
      <div class="mb-3" id="uploadFileContainer" style="display: none;">
        <label class="form-label">Or upload existing JSON file:</label>
        <input type="file" id="uploadFileInput" accept=".json" class="form-control" style="width: auto;" />
        <small>File will be automatically loaded when selected</small>
      </div>

      <!-- GENERATED JSON -->
      <div class="mb-3">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <label class="form-label mb-0">Generated JSON (editable):</label>
          <button type="button" id="downloadBtn" class="btn btn-sm btn-primary" style="display: none;">Download JSON</button>
        </div>
        <textarea id="jsonTextarea" class="form-control" style="display: none;"></textarea>
        <small>You can edit the JSON before uploading</small>
      </div>

      <!-- PROGRESS -->
      <div class="progress-container">
        <div class="progress">
          <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%"></div>
        </div>
        <div id="progressLabel" class="mt-2" style="font-size: 0.9em;">Ready</div>
      </div>

      <!-- BUTTONS -->
      <div class="d-flex gap-3 justify-content-center align-items-center mt-4 flex-wrap">
        <button id="generateBtn" class="btn btn-success px-4" style="min-width: 200px;">Generate JSON</button>
        <button id="uploadBtn" class="btn btn-primary px-4" style="min-width: 200px;">2. Upload to WM</button>
        <div class="form-check ms-2">
          <input class="form-check-input" type="checkbox" id="resetEligibilityCheckbox" />
          <label class="form-check-label" for="resetEligibilityCheckbox">Reset User Eligibility?</label>
        </div>
      </div>
    </div>
  </div>

  <script>
    // DOM Elements
    const orgInput = document.getElementById('org');
    const authBtn = document.getElementById('authBtn');
    const mainUI = document.getElementById('mainUI');
    const statusEl = document.getElementById('status');
    const facilitiesTextarea = document.getElementById('facilitiesTextarea');
    const jsonTextarea = document.getElementById('jsonTextarea');
    const downloadBtn = document.getElementById('downloadBtn');
    const progressBar = document.getElementById('progressBar');
    const progressLabel = document.getElementById('progressLabel');
    const generateBtn = document.getElementById('generateBtn');
    const uploadBtn = document.getElementById('uploadBtn');
    const uploadFileContainer = document.getElementById('uploadFileContainer');
    const uploadFileInput = document.getElementById('uploadFileInput');
    const clearPrefsBtn = document.getElementById('clearPrefsBtn');
    const resetEligibilityCheckbox = document.getElementById('resetEligibilityCheckbox');

    let token = null;
    let jsonEditor = null;

    // Initialize CodeMirror editor
    function initJsonEditor() {
      if (jsonEditor) return;
      jsonEditor = CodeMirror.fromTextArea(jsonTextarea, {
        mode: { name: "javascript", json: true },
        theme: "monokai",
        lineNumbers: true,
        indentUnit: 2,
        autoCloseBrackets: true,
        matchBrackets: true,
        lineWrapping: true
      });
    }

    // Default values (when no localStorage)
    const DEFAULT_FACILITIES = "Atlanta, GA;Jonestown, PA;Toronto, ON;Sydney, NSW";
    const DEFAULT_FILENAME = "FacilityAddresses.json";

    // Ensure ORG is always blank on load (security)
    orgInput.value = '';

    // ===== LOCALSTORAGE PERSISTENCE =====
    const STORAGE_KEY = 'facility_addresses_preferences';
    
    function savePreferences() {
      const prefs = {
        facilities: facilitiesTextarea.value
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(prefs));
      } catch (e) {
        console.warn('Failed to save preferences:', e);
      }
    }
    
    function loadPreferences() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const prefs = JSON.parse(saved);
          if (prefs.facilities !== undefined) {
            facilitiesTextarea.value = prefs.facilities;
          } else {
            facilitiesTextarea.value = DEFAULT_FACILITIES;
          }
        } else {
          // First time - use defaults
          facilitiesTextarea.value = DEFAULT_FACILITIES;
        }
      } catch (e) {
        console.warn('Failed to load preferences:', e);
        // Use defaults on error
        facilitiesTextarea.value = DEFAULT_FACILITIES;
      }
    }
    
    function clearPreferences() {
      try {
        localStorage.removeItem(STORAGE_KEY);
        facilitiesTextarea.value = DEFAULT_FACILITIES;
        if (jsonEditor) {
          jsonEditor.setValue('');
        } else {
          jsonTextarea.value = '';
        }
        downloadBtn.style.display = 'none';
        savePreferences();
        status('Preferences cleared', 'success');
      } catch (e) {
        console.warn('Failed to clear preferences:', e);
      }
    }
    
    // Load preferences on page load
    loadPreferences();

    // Auto-save preferences
    let facilitiesTimeout;
    facilitiesTextarea.addEventListener('input', () => {
      clearTimeout(facilitiesTimeout);
      facilitiesTimeout = setTimeout(() => savePreferences(), 500);
    });

    clearPrefsBtn.addEventListener('click', () => {
      if (confirm('Clear all saved preferences? This will reset to defaults.')) {
        clearPreferences();
      }
    });

    // STATUS
    function status(text, type = 'info') {
      statusEl.textContent = text;
      statusEl.className = `status text-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'}`;
    }

    // API
    async function api(action, data = {}) {
      const headers = { 'Content-Type': 'application/json' };
      if (token) headers.Authorization = `Bearer ${token}`;
      return fetch(`/api/${action}`, {
        method: 'POST',
        headers,
        body: JSON.stringify(data)
      }).then(r => r.json());
    }

    // App opened
    window.addEventListener('load', () => {
      api('app_opened', {});
      orgInput.focus();
      initJsonEditor();
    });

    // Auth
    async function authenticate() {
      const org = orgInput.value.trim();
      if (!org) {
        status('ORG required', 'error');
        mainUI.style.display = 'none';
        
        // Track auth failure in Statsig
        if (window.StatsigTracking && window.StatsigTracking.isInitialized()) {
          window.StatsigTracking.logEvent('auth_failed', {
            error: 'ORG required',
            timestamp: new Date().toISOString()
          });
        }
        
        return;
      }
      
      // Track auth attempt in Statsig
      if (window.StatsigTracking && window.StatsigTracking.isInitialized()) {
        window.StatsigTracking.logEvent('auth_attempt', {
          org: org,
          timestamp: new Date().toISOString()
        });
      }
      
      status('Authenticating...');
      const res = await api('auth', { org });
      if (!res.success) {
        status(res.error || 'Auth failed', 'error');
        mainUI.style.display = 'none';
        
        // Track auth failure in Statsig
        if (window.StatsigTracking && window.StatsigTracking.isInitialized()) {
          window.StatsigTracking.logEvent('auth_failed', {
            org: org,
            error: res.error || 'Auth failed',
            timestamp: new Date().toISOString()
          });
        }
        
        return;
      }
      token = res.token;
      status('Authenticated â€“ ready!', 'success');
      mainUI.style.display = 'block';
      uploadFileContainer.style.display = 'block';
      
      // Track auth success in Statsig
      if (window.StatsigTracking && window.StatsigTracking.isInitialized()) {
        window.StatsigTracking.logEvent('auth_success', {
          org: org,
          timestamp: new Date().toISOString()
        });
      }
    }

    orgInput.addEventListener('keypress', e => {
      if (e.key === 'Enter') authenticate();
    });
    authBtn.onclick = authenticate;

    // Generate JSON with progress updates
    generateBtn.onclick = async () => {
      if (!token) return status('Authenticate first', 'error');
      
      const facilities = facilitiesTextarea.value.trim();
      if (!facilities) return status('Enter facilities', 'error');
      
      const org = orgInput.value.trim();
      if (!org) return status('ORG required', 'error');
      
      // Track generate attempt in Statsig
      if (window.StatsigTracking && window.StatsigTracking.isInitialized()) {
        window.StatsigTracking.logEvent('generate_addresses_attempt', {
          org: org,
          facilities_length: String(facilities.length),
          timestamp: new Date().toISOString()
        });
      }

      // Validate and parse facilities - handle both semicolon and comma separators
      // First split by semicolon to get pairs, then split each pair by comma
      let facilities_list = [];
      const pairs = facilities.split(';').map(p => p.trim()).filter(p => p);
      
      // Validation: Check each pair
      const validationErrors = [];
      
      if (pairs.length === 0) {
        status('No facilities found. Use format: "City, State; City, State"', 'error');
        return;
      }
      
      for (let i = 0; i < pairs.length; i++) {
        const pair = pairs[i];
        const parts = pair.split(',').map(p => p.trim()).filter(p => p);
        
        if (parts.length === 0) {
          validationErrors.push(`Pair ${i + 1} is empty`);
        } else if (parts.length === 1) {
          validationErrors.push(`Pair ${i + 1} ("${pair}") is missing state. Use format: "City, State"`);
        } else if (parts.length > 2) {
          // More than 2 parts - likely has extra commas (e.g., "New York, New York, USA")
          validationErrors.push(`Pair ${i + 1} ("${pair}") has too many commas. Use format: "City, State" (no country or extra info)`);
        } else {
          // Valid pair - exactly 2 parts
          const city = parts[0];
          const state = parts[1];
          
          if (!city) {
            validationErrors.push(`Pair ${i + 1} is missing city name`);
          } else if (!state) {
            validationErrors.push(`Pair ${i + 1} ("${city}") is missing state`);
          } else {
            facilities_list.push(city, state);
          }
        }
      }
      
      // If no semicolons found, try splitting by comma only (legacy format)
      if (facilities_list.length === 0 && pairs.length === 1 && !validationErrors.length) {
        const commaParts = facilities.split(',').map(f => f.trim()).filter(f => f);
        if (commaParts.length % 2 === 0) {
          facilities_list = commaParts;
        } else {
          validationErrors.push('Invalid format. Use semicolons to separate pairs: "City, State; City, State"');
        }
      }
      
      // Show validation errors if any
      if (validationErrors.length > 0) {
        const errorMsg = 'Validation errors:\n' + validationErrors.map((e, idx) => `${idx + 1}. ${e}`).join('\n');
        status(errorMsg, 'error');
        return;
      }
      
      // Final check: must have even number of items (pairs)
      if (facilities_list.length % 2 !== 0) {
        status('Facilities must be in pairs (City, State). Use format: "City, State; City, State"', 'error');
        return;
      }
      
      if (facilities_list.length === 0) {
        status('No valid facilities found. Use format: "City, State; City, State"', 'error');
        return;
      }

      status('Generating addresses...', 'info');
      generateBtn.disabled = true;
      progressBar.style.width = '0%';
      progressLabel.textContent = 'Starting...';

      const results = [];
      const total_pairs = facilities_list.length / 2;

      try {
        // Geocode each pair individually to show progress
        for (let i = 0; i < facilities_list.length; i += 2) {
          const city = facilities_list[i];
          const state = facilities_list[i + 1];
          const pair_num = (i / 2) + 1;
          
          progressLabel.textContent = `Geocoding ${city}, ${state} (${pair_num}/${total_pairs})...`;
          progressBar.style.width = `${((i / 2) / total_pairs) * 100}%`;
          
          const geoRes = await api('geocode', { city, state });
          
          if (!geoRes.success) {
            status(`Error geocoding ${city}, ${state}: ${geoRes.error}`, 'error');
            generateBtn.disabled = false;
            
            // Track generate failure in Statsig
            if (window.StatsigTracking && window.StatsigTracking.isInitialized()) {
              window.StatsigTracking.logEvent('generate_addresses_failed', {
                org: org,
                city: city,
                state: state,
                error: geoRes.error || 'Geocoding failed',
                timestamp: new Date().toISOString()
              });
            }
            
            return;
          }

          const geo_result = geoRes.result;
          // Use corrected state from geocoding
          const corrected_state = geo_result.state || state;
          
          const entry = {
            "FacilityId": `${org}-DM${pair_num}`,
            "FacilityAddress": {
              "Address1": geo_result.address,
              "City": city,
              "State": corrected_state,
              "PostalCode": geo_result.zip_code,
              "Country": geo_result.country
            },
            "Latitude": `${geo_result.lat.toFixed(5)}`,
            "Longitude": `${geo_result.lng.toFixed(5)}`,
            "Description": `${city}-DC`,
            "DmDeployed": "true"
          };
          results.push(entry);
          
          // Update progress after completion
          progressBar.style.width = `${(pair_num / total_pairs) * 100}%`;
          progressLabel.textContent = `Completed ${city}, ${state} (${pair_num}/${total_pairs})`;
          
          // Rate limiting delay (except for last item)
          if (i < facilities_list.length - 2) {
            await new Promise(resolve => setTimeout(resolve, 1100));
          }
        }

        // Display JSON in editor
        const jsonData = { "Data": results };
        const jsonStr = JSON.stringify(jsonData, null, 4);
        if (jsonEditor) {
          jsonEditor.setValue(jsonStr);
        } else {
          jsonTextarea.value = jsonStr;
        }
        downloadBtn.style.display = 'inline-block';
        
        progressBar.style.width = '100%';
        progressLabel.textContent = `Generated ${total_pairs} facility addresses`;
        status(`Generated ${total_pairs} facility addresses!`, 'success');
        
        // Track generate success in Statsig
        if (window.StatsigTracking && window.StatsigTracking.isInitialized()) {
          window.StatsigTracking.logEvent('generate_addresses_completed', {
            org: org,
            facilities_count: String(total_pairs),
            timestamp: new Date().toISOString()
          });
        }
      } catch (e) {
        status(`Error: ${e.message}`, 'error');
        progressLabel.textContent = 'Generation failed';
        
        // Track generate failure in Statsig
        if (window.StatsigTracking && window.StatsigTracking.isInitialized()) {
          window.StatsigTracking.logEvent('generate_addresses_failed', {
            org: org,
            error: e.message || 'Generation failed',
            timestamp: new Date().toISOString()
          });
        }
      } finally {
        generateBtn.disabled = false;
      }
    };

    // Download JSON
    downloadBtn.onclick = () => {
      const jsonStr = jsonEditor ? jsonEditor.getValue().trim() : jsonTextarea.value.trim();
      if (!jsonStr) {
        status('No JSON to download', 'error');
        return;
      }

      try {
        // Validate JSON
        JSON.parse(jsonStr);
        
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = DEFAULT_FILENAME;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        status('File downloaded!', 'success');
      } catch (e) {
        status('Invalid JSON - cannot download', 'error');
      }
    };

    // Auto-load uploaded file when selected
    uploadFileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) {
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const jsonStr = e.target.result;
          // Validate and format JSON
          const jsonObj = JSON.parse(jsonStr);
          const formattedJson = JSON.stringify(jsonObj, null, 4);
          if (jsonEditor) {
            jsonEditor.setValue(formattedJson);
          } else {
            jsonTextarea.value = formattedJson;
          }
          downloadBtn.style.display = 'inline-block';
          status('File loaded into editor', 'success');
        } catch (e) {
          status('Invalid JSON file: ' + e.message, 'error');
          uploadFileInput.value = ''; // Clear the invalid file selection
        }
      };
      reader.onerror = () => {
        status('Error reading file', 'error');
        uploadFileInput.value = '';
      };
      reader.readAsText(file);
    });

    // Upload to WM
    uploadBtn.onclick = async () => {
      if (!token) return status('Authenticate first', 'error');
      
      const jsonStr = jsonEditor ? jsonEditor.getValue().trim() : jsonTextarea.value.trim();
      if (!jsonStr) {
        status('No JSON to upload. Generate or load JSON first.', 'error');
        return;
      }

      // Validate JSON
      let jsonData;
      try {
        jsonData = JSON.parse(jsonStr);
      } catch (e) {
        status('Invalid JSON format', 'error');
        return;
      }

      const org = orgInput.value.trim();
      if (!org) return status('ORG required', 'error');
      
      // Track upload attempt in Statsig
      if (window.StatsigTracking && window.StatsigTracking.isInitialized()) {
        window.StatsigTracking.logEvent('upload_addresses_attempt', {
          org: org,
          json_length: String(jsonStr.length),
          timestamp: new Date().toISOString()
        });
      }

      status('Uploading...', 'info');
      uploadBtn.disabled = true;
      progressBar.style.width = '0%';
      progressLabel.textContent = 'Uploading...';

      try {
        const res = await api('upload', { org, token, json_data: jsonData });
        
        progressBar.style.width = '100%';
        
        if (!res.success) {
          status(res.error || 'Upload failed', 'error');
          progressLabel.textContent = 'Upload Failed';
          
          // Track upload failure in Statsig
          if (window.StatsigTracking && window.StatsigTracking.isInitialized()) {
            window.StatsigTracking.logEvent('upload_addresses_failed', {
              org: org,
              error: res.error || 'Upload failed',
              timestamp: new Date().toISOString()
            });
          }
          
          return;
        }

        let finalStatusMessage = 'Upload complete!';
        let finalProgressLabel = `Upload Complete: ${res.summary}`;
        let alertMessage = res.summary;

        // If requested, perform the additional reset user eligibility call
        if (resetEligibilityCheckbox && resetEligibilityCheckbox.checked) {
          // Derive LocationIds from the JSON payload currently displayed
          let locationIds = [];
          try {
            if (Array.isArray(jsonData?.Data)) {
              locationIds = jsonData.Data
                .map(item => item && item.FacilityId)
                .filter(id => typeof id === 'string' && id.trim().length > 0);
            } else if (Array.isArray(jsonData)) {
              locationIds = jsonData
                .map(item => item && item.FacilityId)
                .filter(id => typeof id === 'string' && id.trim().length > 0);
            }
          } catch (e) {
            // If anything goes wrong, fall back to no locations
            locationIds = [];
          }

          if (locationIds.length > 0) {
            const resetRes = await api('reset_user_eligibility', {
              org,
              token,
              location_ids: locationIds
            });

            if (!resetRes.success) {
              finalStatusMessage = 'Upload complete, but user eligibility reset failed';
              finalProgressLabel += ' | User eligibility reset failed';
              alertMessage += `\n\nUser eligibility reset failed: ${resetRes.error || 'Unknown error'}`;
            } else {
              finalStatusMessage = 'Upload complete and user eligibility reset!';
              finalProgressLabel += ' | User eligibility reset';
              if (resetRes.summary) {
                alertMessage += `\n\nUser eligibility reset:\n${resetRes.summary}`;
              } else {
                alertMessage += `\n\nUser eligibility reset completed.`;
              }
            }
          } else {
            finalStatusMessage = 'Upload complete, but no FacilityIds found for user eligibility reset';
            finalProgressLabel += ' | No FacilityIds for reset';
            alertMessage += `\n\nNo FacilityIds found in JSON for user eligibility reset.`;
          }
        }

        progressLabel.textContent = finalProgressLabel;
        status(finalStatusMessage, 'success');
        
        // Track upload success in Statsig
        if (window.StatsigTracking && window.StatsigTracking.isInitialized()) {
          window.StatsigTracking.logEvent('upload_addresses_completed', {
            org: org,
            total: String(res.total || 0),
            success: String(res.success || 0),
            failed: String(res.failed || 0),
            timestamp: new Date().toISOString()
          });
        }
        
        // Show summary in alert
        alert(alertMessage);
      } catch (e) {
        status(`Error: ${e.message}`, 'error');
        progressLabel.textContent = 'Upload Failed';
        
        // Track upload failure in Statsig
        if (window.StatsigTracking && window.StatsigTracking.isInitialized()) {
          window.StatsigTracking.logEvent('upload_addresses_failed', {
            org: org,
            error: e.message || 'Upload failed',
            timestamp: new Date().toISOString()
          });
        }
      } finally {
        uploadBtn.disabled = false;
      }
    };
  </script>
  <!-- Statsig Analytics -->
  <script src="statsig.js"></script>
  <!-- Vercel Analytics -->
  <script>
    (function() {
      const script = document.createElement('script');
      script.src = '/_vercel/insights/script.js';
      script.defer = true;
      script.onerror = function() {
        console.warn('Vercel Analytics script failed to load. Make sure Analytics is enabled in Vercel dashboard and the app is redeployed.');
      };
      document.head.appendChild(script);
    })();
  </script>
</body>
</html>

